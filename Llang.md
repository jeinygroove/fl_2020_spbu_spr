# Язык Llang

## Переменные и ключевые слова

Именем переменной может служить любая строка, состоящая из символов латинского алфавита, цифр и символа `_`. Первым символом при этом может быть либо символ латинского алфавита, либо `_`. Пишите сколько хотите пробелов, но перенос строки автор 
языка приветствовать в версии 1.0 не будет. 

Также у нас есть ключевые слова, которыми нельзя называть переменные: **If, While, Read, Write, Seq, Assign**

### Примеры имен:
#### Корректные: 
- _hello
- Foo
- ba123
#### Некорректные:
- If
- 1abc
- @catch

## Выражения, операторы
| Оператор | Описание | Приоритет| Ассоциативность/Унарность |
| ------ | ----------- |----------- |----------- |
| `\|\|`  | Логическое ИЛИ, 1 если хотя бы одна часть не равна 0 | 2| Правоассоциативный |
| `&&` | Логическое И | 3 | Правоассоциативный |
| `!`  | Логическое НЕ| 3 | Унарный |
| `==`    | Равенство после редукции(вычисления) обоих частей | 4| Неассоциативный |
| `/=`| Результат оператора противоположен `==`| 4| Неассоциативный |
| `>=`| 1, если левая часть больше или равна правой, 0 иначе | 4| Неассоциативный |
| `>`| 1, если левая часть строго больше правой, 0 иначе | 4| Неассоциативный |
| `<=`| 1, если левая часть меньше или равна правой, 0 иначе | 4| Неассоциативный |
| `<`| 1, если левая часть строго меньше правой, 0 иначе | 4| Неассоциативный |
| `+`| сумма значений левой и правой части | 5| Левоассоциативный |
| `-`| разность значений левой и правой части | 5| Левоассоциативный |
| `*`| произведение значений левой и правой части | 6| Левоассоциативный |
| `/`| целочисленное деление значений левой и правой части (округление вниз) | 6| Левоассоциативный |
| `-`| Унарный минус | 7| Унарный |
| `^`| возведение в левой части в степень правой | 8| Правоассоциативный |

Можно писать скобки для того, чтобы задавать приоритет, использование операторов допустимо только с корректными выражениями (натуральные числа, 0, имя объявленной переменной,
образованные из них конструкции.

### Примеры:
#### Корректные:
- 2||!3
- (2+1)
- (-var)
- (1 + 3) || (2+5)
- 40+-2 (то же, что и 40 + (-2))
- -3^2 ~ -9 ~ -(3^2)
#### Некорректные:
- a-b, где a не объявлена
- +42
- --var
- !!0

## Функции
Функции объявляются с помощью конструкции `Def` в начале программы. Функция объявлена корректно, если в ней нет необъявленных
переменных и переменных, объявленных после использования. Функции еще умеют что-то возвращать с помощью `Return`. Если 
функция ничего не возвращает или доходит до конца тела, ничего не вернув, (да даже если и возвращает), то в конец тела автоматически дописывается 
`Return (0);`.

## Конструкции
| Конструкция | Использование | Описание |
| ------ | -------------- |----------- |
| If  | If (Expr) (b1) (b2) | Если значение выражения Expr не 0, исполняет команду b1, иначе - b2|
| While | While (Expr) (body) | Пока значение Expr не 0, исполняем команду body |
| Read    | Read (var) | Считывает из внешнего окружения число и связываем переменную с именем var с ним|
| Write| Write (expr)| Вычисляет expr и записывает во внешний мир результат|
| Seq| Seq { b1; b2; ...; bk} | Последовательно выполняет b1, ..., bk|
| Assign| Assign (var) (expr) | Связывает переменную с именем var (если ее не было, то создает новую) с expr |
| Def | Def (name) (arg1, arg2, ..., argN) (Seq {...}) | Объявление и определение функции |
| Return | Return (expr) | Возвращаем выражение (используется в теле функции) |

P.S. Скобок много, если при написании кода у вас это будет вызывать раздражение, то знайте, автор языка вам искренне сочувствует.

Программа считается корректной, если она корректно образована с использованием приведенных выше конструкций, выражений, операторов.
Помимо этого требуется, чтобы имена переменных в выражениях были объявлены до этого выражения. Также необходимо, чтобы все вызовы функций
вызывали определенные функции (то есть функция с таким именем и с таким числом аргументов должна существовать). Отметим, что
вызов функции (например, из тела другой) может быть раньше объявления функции.
Сама программа - это какое-то количество объявлений функций и контрукция `Seq`(аналог main).

Пример: 

- Вычисление факториала:
 `Def (fact) (n) (Seq {Assign (i) (1); While (n > 0) (Seq {Assign (i) (n*i); Assign (n) (n-1);}); Return (i);}) Seq {Read (n); Write (fact(n));}`
